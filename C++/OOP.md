# ✔️[OOP] 
### 절차지향 프로그래밍

- **개발 방법**: 무한 루프 속에서 순서를 정하여 코드를 구현.
- **기능 추가**: 개발자마다 기능 추가 방법이 다르며, 각자 다른 방식으로 유지보수를 진행할 수 있음.
- **유지보수 어려움**: main() 함수에 코드를 몰아넣을 경우, 유지보수가 어려워지며, 버그 찾는 데 시간이 오래 걸림. 다른 개발자가 코드를 예측하기 어려움.

### 객체지향 프로그래밍

- **개념**: 각 모듈은 생명체의 장기처럼 독립적인 역할을 수행하며, 다른 모듈과 신호를 주고받으며 시스템을 구성함.
- **설계**: 시작 시 어떤 모듈들이 필요한지 고민하며, 모듈화된 구조로 구현하여 유지보수성을 높임.
- **유지보수 장점**: 객체지향적 설계는 빠른 디버깅과 기능 추가가 가능해 유지보수 비용을 줄임.
- **SW공학 목표**: 유지보수성이 좋은 코드를 작성하여 SW 비용, 특히 인건비를 절감하는 것이 목표.

### 객체지향 프로그래밍의 필요성

- **대표적인 시스템**: 자동차처럼 여러 모듈이 구성되어 하나의 시스템을 이루는 방식이 이상적임.
- **유지보수 효율성**: 버그가 발생하면 해당 모듈만 점검하면 되며, 기능 추가 시에도 어느 모듈에 추가할지 명확하여 유지보수가 용이함.
- **SW 비용 절감**: 유지보수가 쉬운 코드를 작성함으로써 SW 비용을 줄이고, 버그 발생 확률을 낮춰 품질을 확보할 수 있음.

### 성능과 유지보수성의 균형

- **OOP의 속도 이슈**: 객체지향 코드가 절차지향 코드보다 10ms 느릴 수 있음. 그러나 유지보수성이 뛰어나 유지보수 비용 절감 효과가 큼.
- **예외 사례**: 드론, 미사일 같은 정밀 기계는 성능 평가가 필요하며, 모든 코드가 절차지향일 필요는 없음.
- **반도체 회사 사례**: 성능이 중요한 경우, C++과 C를 적절히 사용해 성능과 유지보수성을 조절함.

### 결론

- **유지보수성 강화**: 객체지향 프로그래밍을 통해 유지보수성이 향상되면, SW 비용을 줄일 수 있음.
- **버그 감소**: 유지보수성이 높은 코드로 인해 버그 발생 확률이 줄어들어, SW 품질을 높일 수 있음.
- **현실적인 이점**: OOP를 사용하면 기능 추가와 버그 수정이 빨라져, 인건비를 절감할 수 있고, 고객 불만을 줄일 수 있음.

---

### 모듈화

- **개념**: 특정 기능 요소를 추가할 수 있도록 시스템을 구성하는 방식.
- **속성**: 모듈은 `Attribute`(속성)와 `Behavior`(행동)를 가짐.
- **설계 원칙**: 모듈은 한 가지 책임을 갖도록 설계해야 하며, 응집도(Cohesion)가 높아야 함.

### 의존도

- **개념**: 한 모듈이 다른 모듈에 의존하는 정도.
- **영향**: 의존성이 크면, 의존 대상의 변경이 큰 영향을 미침. 의존성이 낮으면, 변경에 대한 영향이 적음.
- **예시**: 유진이가 도진이에게 의존성이 크면, 도진이의 변화가 유진이의 삶에 큰 영향을 미침.

### 추상화

- **개념**: 복잡한 시스템을 단순화하여 중요한 요소만을 남기고, 불필요한 세부사항을 감추는 것.

### UML (Unified Modeling Language)

- **정의**: OOP(객체지향 프로그래밍) 세상에서 사실상 표준으로 사용되는 설계 다이어그램 표현 방식.
- **용도**: 설계한 시스템을 그림(다이어그램)으로 표현할 때 사용.

### 유지보수성

- **개념**: 시스템을 쉽게 수정하고 개선할 수 있는 능력.
- **Loose Coupling vs Tight Coupling**: 유지보수성을 높이기 위해 `Loose Coupling`(느슨한 결합)을 선호해야 함.

### 객체지향 설계의 원칙

- **추상화**: 시스템이 적절하게 추상화되어야 함.
- **모듈화**: 적절한 크기의 작은 모듈로 시스템이 구성되어야 함.
- **커플링**: 모듈 간 결합은 느슨하게, 즉 `Loose Coupling`이 되도록 해야 함.
- **응집도**: 하나의 모듈은 응집도가 높도록 설계되어야 함.

---

# Interface

### 1. **인터페이스 (`interface`)**

- **정의**: C++에서는 `interface`라는 키워드가 없지만, 구조체(`struct`)와 순수 가상 함수(pure virtual function)를 사용하여 인터페이스를 구현할 수 있음.
- **역할**: 인터페이스를 사용하면 클래스들 간의 결합도를 낮출 수 있으며, 다른 클래스를 수정하지 않고 새로운 클래스를 쉽게 추가할 수 있음. 이는 유지보수와 확장성에 유리함.
- **코드 예시**:
    
    ```cpp
    interface RC {
        virtual void tvON() = 0;  // 순수 가상 함수
        virtual void tvOFF() = 0;
    };
    ```
    
- **설명**: `= 0`으로 선언된 순수 가상 함수는 하위 클래스에서 반드시 오버라이딩해야 하며, 이로 인해 인터페이스의 역할을 충실히 수행하게 됨.

### 2. **순수 가상 함수 (`pure virtual function`)**

- **정의**: 함수의 구현이 없고, 하위 클래스에서 반드시 구현해야 하는 함수. 인터페이스를 구성하는 주요 요소임.
- **설명**: 예를 들어, `RC` 인터페이스의 `tvON()` 함수는 `= 0`으로 선언되어 있으므로, `LGTV`나 `SamsungTV` 클래스에서 반드시 구현해야 함.

### 3. **클래스 상속과 오버라이딩**

- **상속**: `LGTV`와 `SamsungTV` 클래스는 `RC` 인터페이스를 상속받아 각각 `tvON()`과 `tvOFF()` 함수를 구현함.
- **오버라이딩**: `override` 키워드를 사용하여 부모 클래스(`RC`)의 순수 가상 함수를 재정의함으로써, 각각의 클래스에 맞는 동작을 구현함.
- **코드 예시**:
    
    ```cpp
    class LGTV : public RC {
    public:
        virtual void tvON() override {
            zizic(); zizic(); zizic();
        }
        virtual void tvOFF() override {
            zizic(); zizic(); zizic();
        }
    private:
        void zizic() {
            std::cout << "지지직\n";
        }
    };
    ```
    

### 4. **의존성 주입 (`Dependency Injection`)**

- **정의**: 객체를 직접 생성하지 않고 외부에서 주입받아 사용하는 방식으로, 의존성을 줄이고 코드의 유연성을 높이는 디자인 패턴.
- **코드 예시**:
    
    ```cpp
    class Recode {
    public:
        void gogo(RC *remote) {
            remote->tvON();
            std::cout << "녹화시작\n";
            remote->tvOFF();
        }
    };
    ```
    
- **설명**: `Recode` 클래스는 `RC` 인터페이스에 의존하여 동작하며, 구체적인 `SamsungTV`나 `LGTV` 클래스의 구현에 의존하지 않음. 이렇게 함으로써 `Recode` 클래스는 어떤 `RC` 구현체가 오더라도 동일한 방식으로 동작할 수 있음.

### 5. **클라이언트 코드**

- **설명**: 최종적으로 `main()` 함수에서 `SamsungTV` 객체를 생성하고, 이를 `Recode` 객체의 `gogo()` 함수에 전달하여 녹화를 시작하고 종료하는 클라이언트 코드를 작성함.
- **코드 예시**:
    
    ```cpp
    int main()
    {
        RC *remote = new SamsungTV();
        Recode *rec = new Recode();
        rec->gogo(remote);
    }
    ```
    
- **핵심**: `Recode` 클래스는 `RC` 인터페이스만 알고 있기 때문에, `SamsungTV`가 아닌 다른 TV 클래스(`LGTV` 등)를 사용하더라도 코드 변경 없이 동작할 수 있음. 이를 통해 클라이언트 코드의 유연성을 높일 수 있음.
